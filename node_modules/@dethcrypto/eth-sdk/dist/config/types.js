"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEthSdkConfig = exports.parseEthSdkConfig = exports.flagsSchema = exports.networkIdsSchema = exports.ethSdKContractsSchema = exports.parseAddress = void 0;
const zod_1 = require("zod");
const networks_1 = require("../abi-management/networks");
const DEFAULT_OUTPUT_PATH = './node_modules/.dethcrypto/eth-sdk-client';
const DEFAULT_ABI_SOURCE = 'etherscan';
const ADDRESS_ERROR_MESSAGE = 'An address must be 42 characters hexadecimal number string.';
const addressSchema = zod_1.z
    .string()
    .length(42, { message: ADDRESS_ERROR_MESSAGE })
    .regex(/^0x[0-9a-fA-F]+$/, { message: ADDRESS_ERROR_MESSAGE });
/**
 * @see https://info.etherscan.com/what-is-an-ethereum-address/
 * @param address - string representation of an address
 * @returns the same string branded as Address if it's a valid address
 */
function parseAddress(address) {
    const res = addressSchema.safeParse(address);
    if (res.success)
        return res.data;
    else {
        const errorCode = res.error.issues[0].code;
        throw new Error(`"${address}" is not an address. ${ADDRESS_ERROR_MESSAGE} (${errorCode})`);
    }
}
exports.parseAddress = parseAddress;
const nestedAddressesSchema = zod_1.z.lazy(() => zod_1.z.record(zod_1.z.union([addressSchema, nestedAddressesSchema])));
exports.ethSdKContractsSchema = zod_1.z.record(nestedAddressesSchema);
const etherscanURLsSchema = zod_1.z.record(zod_1.z.string());
const etherscanKeysSchema = zod_1.z.record(zod_1.z.string());
const rpcUrlsSchema = zod_1.z.record(zod_1.z.string());
const abiSourceSchema = zod_1.z.union([zod_1.z.literal('etherscan'), zod_1.z.literal('sourcify')]);
exports.networkIdsSchema = zod_1.z.record(zod_1.z.number());
exports.flagsSchema = zod_1.z.object({
    tsNocheck: zod_1.z.optional(zod_1.z.boolean()),
    discriminateTypes: zod_1.z.boolean(),
    alwaysGenerateOverloads: zod_1.z.boolean(),
});
const ethSdkConfigSchema = zod_1.z
    .object({
    contracts: exports.ethSdKContractsSchema,
    outputPath: zod_1.z.string().default(DEFAULT_OUTPUT_PATH),
    etherscanKey: zod_1.z.string().optional(),
    etherscanKeys: etherscanKeysSchema.default({}),
    etherscanURLs: etherscanURLsSchema.default({}),
    rpc: rpcUrlsSchema.default({}),
    noFollowProxies: zod_1.z.boolean().optional(),
    abiSource: abiSourceSchema.default(DEFAULT_ABI_SOURCE),
    networkIds: exports.networkIdsSchema.default({}),
    typechainFlags: exports.flagsSchema.optional(),
})
    .strict();
function parseEthSdkConfig(data) {
    const res = ethSdkConfigSchema.safeParse(data);
    if (res.success) {
        return res.data;
    }
    else {
        const message = 'Failed to parse eth-sdk config';
        const [issue] = res.error.issues;
        if (issue.code === 'invalid_union') {
            const [error] = issue.unionErrors[0].errors;
            if (error.code === 'invalid_type' && error.expected in networks_1.symbolToNetworkId) {
                throw new Error(message +
                    '.\n' +
                    `Network "${error.received}" is not supported.\n` +
                    'Supported networks are:' +
                    Object.values(networks_1.networkIDtoSymbol)
                        .sort()
                        .reduce((acc, net) => acc + `\n  - ${net}`, ''));
            }
        }
        throw new Error(message +
            ':\n' +
            res.error.issues.map((issue) => `${issue.code} at "${issue.path.join('.')}": ${issue.message}`).join('\n'));
    }
}
exports.parseEthSdkConfig = parseEthSdkConfig;
/** @internal */
exports.createEthSdkConfig = parseEthSdkConfig;
//# sourceMappingURL=types.js.map