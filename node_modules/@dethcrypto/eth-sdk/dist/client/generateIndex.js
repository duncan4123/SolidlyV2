"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importedAbiIdentifier = exports.generateIndex = void 0;
const debug_1 = __importDefault(require("debug"));
const lodash_1 = require("lodash");
const path_1 = require("path");
const typechain_1 = require("typechain");
const traverse_1 = require("../config/traverse");
const fs_1 = require("../peripherals/fs");
const unsafeKeys_1 = require("../utils/unsafeKeys");
const d = (0, debug_1.default)('@dethcrypto/eth-sdk:client');
async function generateIndex(contracts, outputPath, outputToAbiRelativePath, fs = fs_1.realFs) {
    d('Generating index file');
    const indexPath = (0, path_1.join)(outputPath, './index.ts');
    const index = `
import { providers, Signer, Contract } from 'ethers'

import * as types from './types'

${await getAbiImports(contracts, outputToAbiRelativePath)}

export function getContract(address: string, abi: object, defaultSignerOrProvider: Signer | providers.Provider) {
  return new Contract(address, abi, defaultSignerOrProvider)
}

  ${(0, unsafeKeys_1.unsafeKeys)(contracts)
        .map((network) => generateNetworkSdk(network, contracts)) // fix path to abi here
        .join('\n\n')}
  `;
    await fs.write(indexPath, index);
}
exports.generateIndex = generateIndex;
function importedAbiIdentifier(keys) {
    const name = (0, typechain_1.normalizeName)([...keys, 'abi'].join('_'));
    return name[0].toLowerCase() + name.slice(1);
}
exports.importedAbiIdentifier = importedAbiIdentifier;
async function getAbiImports(sdkDef, outputToAbiRelativePath) {
    const paths = [];
    await (0, traverse_1.traverseContractsMap)(sdkDef, (network, keys) => void paths.push([network, ...keys]));
    return paths
        .map((path) => {
        const importPath = '../' + outputToAbiRelativePath + '/' + path.join('/') + '.json';
        return `import ${importedAbiIdentifier(path)} from '${importPath}'`;
    })
        .join('\n');
}
function generateNetworkSdk(networkSymbol, sdkDef) {
    const nestedAddresses = sdkDef[networkSymbol];
    const network = pascalCase(networkSymbol);
    return `
export type ${network}Sdk = ReturnType<typeof get${network}Sdk>
export function get${network}Sdk(defaultSignerOrProvider: Signer | providers.Provider) {
  return ${generateBody(nestedAddresses, [networkSymbol], true)}
}
`;
}
function generateBody(nestedAddresses, keys, topLevel = false) {
    const body = ['{'];
    for (const [key, addressOrNested] of Object.entries(nestedAddresses)) {
        if (typeof addressOrNested === 'string') {
            const address = addressOrNested;
            const abi = importedAbiIdentifier([...keys, key]);
            const path = [...keys.map(lodash_1.camelCase), (0, typechain_1.normalizeName)(key)].join('.');
            body.push(`"${key}": getContract('${address}', ${abi}, defaultSignerOrProvider) as types.${path},`);
        }
        else {
            body.push(`"${key}":`);
            body.push(generateBody(addressOrNested, [...keys, key]));
        }
    }
    body.push(`}`);
    if (!topLevel) {
        body.push(`,`);
    }
    return body.join('\n');
}
function pascalCase(str) {
    return str[0].toUpperCase() + (0, lodash_1.camelCase)(str).slice(1);
}
//# sourceMappingURL=generateIndex.js.map